import { AIModelRouter } from './modelRouter';

export interface CodeCompletionRequest {
  code: string;
  language: string;
  cursorPosition?: number;
  context?: {
    fileName?: string;
    projectType?: string;
    imports?: string[];
    dependencies?: string[];
  };
}

export interface CodeCompletionResponse {
  completions: {
    text: string;
    insertText: string;
    kind: 'function' | 'variable' | 'class' | 'method' | 'property' | 'keyword' | 'snippet';
    detail?: string;
    documentation?: string;
    confidence: number;
  }[];
  model: string;
  cost: number;
}

export class CodeCompletionService {
  constructor(private aiRouter: AIModelRouter) {}

  async getCompletions(request: CodeCompletionRequest): Promise<CodeCompletionResponse> {
    const prompt = this.buildCompletionPrompt(request);
    
    const aiResponse = await this.aiRouter.processRequest({
      type: 'completion',
      content: prompt,
      language: request.language,
      model: 'auto' // Let AI router choose the best model for completion
    });

    return this.parseCompletions(aiResponse, request);
  }

  private buildCompletionPrompt(request: CodeCompletionRequest): string {
    let prompt = `Complete the following ${request.language} code. Provide multiple completion options with different approaches.\n\n`;
    
    if (request.context) {
      if (request.context.projectType) {
        prompt += `Project Type: ${request.context.projectType}\n`;
      }
      if (request.context.imports?.length) {
        prompt += `Available imports: ${request.context.imports.join(', ')}\n`;
      }
      if (request.context.dependencies?.length) {
        prompt += `Dependencies: ${request.context.dependencies.join(', ')}\n`;
      }
      prompt += '\n';
    }

    prompt += 'Code to complete:\n```' + request.language + '\n';
    prompt += request.code;
    
    if (request.cursorPosition !== undefined) {
      // Insert cursor marker at position
      const beforeCursor = request.code.substring(0, request.cursorPosition);
      const afterCursor = request.code.substring(request.cursorPosition);
      prompt += beforeCursor + '|CURSOR|' + afterCursor;
    }
    
    prompt += '\n```\n\n';
    prompt += 'Provide 3-5 different completion options in JSON format:\n';
    prompt += '{\n';
    prompt += '  "completions": [\n';
    prompt += '    {\n';
    prompt += '      "text": "completed code snippet",\n';
    prompt += '      "insertText": "text to insert at cursor",\n';
    prompt += '      "kind": "function|variable|class|method|property|keyword|snippet",\n';
    prompt += '      "detail": "brief description",\n';
    prompt += '      "documentation": "detailed explanation",\n';
    prompt += '      "confidence": 0.95\n';
    prompt += '    }\n';
    prompt += '  ]\n';
    prompt += '}\n';

    return prompt;
  }

  private parseCompletions(aiResponse: any, request: CodeCompletionRequest): CodeCompletionResponse {
    try {
      // Try to extract JSON from the AI response
      const jsonMatch = aiResponse.content.match(/```json\n([\s\S]*?)\n```/) || 
                       aiResponse.content.match(/\{[\s\S]*\}/);
      
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);
        
        if (parsed.completions && Array.isArray(parsed.completions)) {
          return {
            completions: parsed.completions.map((comp: any) => ({
              text: comp.text || '',
              insertText: comp.insertText || comp.text || '',
              kind: comp.kind || 'snippet',
              detail: comp.detail || '',
              documentation: comp.documentation || '',
              confidence: Math.min(1, Math.max(0, comp.confidence || 0.8))
            })),
            model: aiResponse.model,
            cost: aiResponse.cost
          };
        }
      }
    } catch (error) {
      console.error('Failed to parse AI completion response:', error);
    }

    // Fallback: create a single completion from the raw response
    return {
      completions: [{
        text: aiResponse.content,
        insertText: aiResponse.content,
        kind: 'snippet',
        detail: 'AI Generated Code',
        documentation: `Generated by ${aiResponse.model}`,
        confidence: aiResponse.confidence || 0.7
      }],
      model: aiResponse.model,
      cost: aiResponse.cost
    };
  }

  /**
   * Get intelligent code suggestions based on context
   */
  async getIntelligentSuggestions(request: CodeCompletionRequest): Promise<{
    suggestions: {
      title: string;
      description: string;
      code: string;
      category: 'improvement' | 'fix' | 'optimization' | 'security';
      confidence: number;
    }[];
    model: string;
    cost: number;
  }> {
    const prompt = `Analyze the following ${request.language} code and provide intelligent suggestions for improvement, fixes, optimizations, or security enhancements.

Code:
\`\`\`${request.language}
${request.code}
\`\`\`

Context: ${JSON.stringify(request.context, null, 2)}

Provide suggestions in JSON format:
{
  "suggestions": [
    {
      "title": "Brief title",
      "description": "Detailed explanation",
      "code": "improved code snippet",
      "category": "improvement|fix|optimization|security",
      "confidence": 0.95
    }
  ]
}`;

    const aiResponse = await this.aiRouter.processRequest({
      type: 'optimization',
      content: prompt,
      language: request.language,
      model: 'auto'
    });

    try {
      const jsonMatch = aiResponse.content.match(/```json\n([\s\S]*?)\n```/) || 
                       aiResponse.content.match(/\{[\s\S]*\}/);
      
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);
        
        if (parsed.suggestions && Array.isArray(parsed.suggestions)) {
          return {
            suggestions: parsed.suggestions.map((sug: any) => ({
              title: sug.title || 'Suggestion',
              description: sug.description || '',
              code: sug.code || '',
              category: sug.category || 'improvement',
              confidence: Math.min(1, Math.max(0, sug.confidence || 0.7))
            })),
            model: aiResponse.model,
            cost: aiResponse.cost
          };
        }
      }
    } catch (error) {
      console.error('Failed to parse AI suggestions response:', error);
    }

    return {
      suggestions: [],
      model: aiResponse.model,
      cost: aiResponse.cost
    };
  }
}

export const codeCompletionService = new CodeCompletionService(
  new AIModelRouter()
);